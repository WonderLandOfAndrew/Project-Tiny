/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */

terminal SEMI, PLUS, MINUS, UMINUS, TIMES, DIVIDE, QCHAR;
terminal LPAR, RPAR, LBRACE, RBRACE, LBRACK, RBRACK;
terminal IF, ELSE, WHILE, RETURN, WRITE, READ, LENGTH;
terminal GREATER, LESS, ASSIGN, EQUALEQUAL, NEQUAL, NOT, EQUAL, COMMA;  // Add new terminals here
terminal INT;
terminal CHAR;
terminal String NAME;

terminal Integer    NUMBER;        // our scanner provides numbers as integers

/* Non terminals */
non terminal program;
non terminal declaration;
non terminal fun_declaration;
non terminal formal_pars;
non terminal formal_par;
non terminal block;
non terminal var_declaration;
non terminal type;
non terminal statements;
non terminal statement;
non terminal lexp;
non terminal exp;
non terminal binop;
non terminal unop;
non terminal pars;
non terminal var;
non terminal epsilon;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left GREATER, LESS;
precedence left EQUALEQUAL, NEQUAL;
precedence left UMINUS;

/* The grammar rules */

program ::= program declaration 
			| declaration
			;

declaration ::= fun_declaration 
			| var_declaration
			;

fun_declaration ::= type NAME LPAR formal_pars RPAR block;

formal_pars ::= formal_pars COMMA formal_par 
              | formal_par
              ;

formal_par ::= type NAME;

block ::= LBRACE var_declaration statements RBRACE;

var_declaration ::= type NAME SEMI;

type			::= INT
				|	CHAR
				|	type LBRACK exp RBRACK
				; // array type

statements ::= statements SEMI statement
			| statement	
			;
			
statement  ::= IF LPAR exp RPAR statement
            | IF LPAR exp RPAR statement ELSE statement
            | WHILE LPAR exp RPAR statement
			| lexp ASSIGN exp
            | RETURN exp
			| NAME LPAR pars RPAR
            | block
            | WRITE exp
            | READ lexp
            ;

lexp		::= var
			|	lexp LBRACK exp RBRACK;	// array access

exp			::=	lexp
			|	exp binop exp
			|	unop exp
			|	LPAR exp RPAR
			|	NUMBER
			|	NAME LPAR pars RPAR // function call
			|	QCHAR
			|	LENGTH lexp; // size of array
			
binop		::= MINUS
			|	PLUS
			|	TIMES
			|	DIVIDE
			|	EQUAL
			|	NEQUAL
			|	GREATER
			|	LESS;
			
unop		::= MINUS
			|	NOT;

pars		::= pars COMMA exp 
			|	exp
			|   
			;		

var			::= NAME;

       